#include "alphabet.h"
/* Example: A
boolean A[8][5]={
	0, 1, 1, 1, 0,
	1, 0, 0, 0, 1,
	1, 0, 0, 0, 1,
	1, 0, 0, 0, 1,
	1, 1, 1, 1, 1,
	1, 0, 0, 0, 1,
	1, 0, 0, 0, 1,
	1, 0, 0, 0, 1,
}
Son 8x5=40 valores binarios. Se pueden pasar a 5 bytes.
Representando cada columna como un byte, en sentido IZQ a DER y de ARRIBA a ABAJO:
A = 01111111 10001000 10001000 10001000 01111111
A = 0x7F     0x88     0x88     0x88     0x7F
const char A[5]= {0x7F, 0x88, 0x88, 0x88, ,0x7F}      
*/
const char uppercase_alphabet[ALPHABET_SIZE][CHAR_WIDTH] = {
	{0x7F, 0x88, 0x88, 0x88, 0x7F}, //  A
	{0xFF, 0x91, 0x91, 0x91, 0x6E}, //  B
	{0x7E, 0x81, 0x81, 0x81, 0x42}, //  C
	{0xFF, 0x81, 0x81, 0x42, 0x3C}, //  D
	{0xFF, 0x91, 0x91, 0x91, 0x81}, //  E
	{0xFF, 0x90, 0x90, 0x90, 0x80}, //  F
	{0x7E, 0x81, 0x89, 0x89, 0x4E}, //  G
	{0xFF, 0x10, 0x10, 0x10, 0xFF}, //  H
	{0x81, 0x81, 0xFF, 0x81, 0x81}, //  I
	{0x06, 0x01, 0x01, 0x01, 0xFE}, //  J
	{0xFF, 0x18, 0x24, 0x42, 0x81}, //  K
	{0xFF, 0x01, 0x01, 0x01, 0x01}, //  L
	{0xFF, 0x40, 0x30, 0x40, 0xFF}, //  M
	{0xFF, 0x40, 0x30, 0x08, 0xFF}, //  N
	{0x7E, 0x81, 0x81, 0x81, 0x7E}, //  O
	{0xFF, 0x88, 0x88, 0x88, 0x70}, //  P
	{0x7E, 0x81, 0x85, 0x82, 0x7D}, //  Q
	{0xFF, 0x88, 0x8C, 0x8A, 0x71}, //  R
	{0x61, 0x91, 0x91, 0x91, 0x8E}, //  S
	{0x80, 0x80, 0xFF, 0x80, 0x80}, //  T
	{0xFE, 0x01, 0x01, 0x01, 0xFE}, //  U
	{0xF0, 0x0C, 0x03, 0x0C, 0xF0}, //  V
	{0xFF, 0x02, 0x0C, 0x02, 0xFF}, //  W
	{0xC3, 0x24, 0x18, 0x24, 0xC3}, //  X
	{0xE0, 0x10, 0x0F, 0x10, 0xE0}, //  Y
	{0x83, 0x85, 0x99, 0xA1, 0xC1}  //  Z	
};

const char lowercase_alphabet[ALPHABET_SIZE][CHAR_WIDTH] = {
	{0x06, 0x29, 0x29, 0x29, 0x1F}, //  a
	{0xFF, 0x09, 0x11, 0x11, 0x0E}, //  b
	{0x1E, 0x21, 0x21, 0x21, 0x12}, //  c
	{0x0E, 0x11, 0x11, 0x09, 0xFF}, //  d
	{0x0E, 0x15, 0x15, 0x15, 0x0C}, //  e
	{0x08, 0x7F, 0x88, 0x80, 0x40}, //  f
	{0x30, 0x49, 0x49, 0x49, 0x7E}, //  g
	{0xFF, 0x08, 0x10, 0x10, 0x0F}, //  h
	{0x00, 0x00, 0x5F, 0x00, 0x00}, //  i
	{0x02, 0x01, 0x21, 0xBE, 0x00}, //  j
	{0xFF, 0x04, 0x0A, 0x11, 0x00}, //  k
	{0x00, 0x81, 0xFF, 0x01, 0x00}, //  l
	{0x3F, 0x20, 0x18, 0x20, 0x1F}, //  m
	{0x3F, 0x10, 0x20, 0x20, 0x1F}, //  n
	{0x0E, 0x11, 0x11, 0x11, 0x0E}, //  o
	{0x3F, 0x24, 0x24, 0x24, 0x18}, //  p
	{0x10, 0x28, 0x28, 0x18, 0x3F}, //  q
	{0x1F, 0x08, 0x10, 0x10, 0x08}, //  r
	{0x09, 0x15, 0x15, 0x15, 0x02}, //  s
	{0x20, 0xFE, 0x21, 0x01, 0x02}, //  t
	{0x1E, 0x01, 0x01, 0x02, 0x1F}, //  u
	{0x1C, 0x02, 0x01, 0x02, 0x1C}, //  v
	{0x1E, 0x01, 0x0E, 0x01, 0x1E}, //  w
	{0x11, 0x0A, 0x04, 0x0A, 0x11}, //  x
	{0x00, 0x39, 0x05, 0x05, 0x3E}, //  y
	{0x11, 0x13, 0x15, 0x19, 0x11}  //  z	
};

const char numbers[10][CHAR_WIDTH] = {
	{0x7E, 0x89, 0x91, 0xA1, 0x7E}, //  0	
	{0x00, 0x41, 0xFF, 0x01, 0x00}, //  1
	{0x43, 0x85, 0x89, 0x91, 0x61}, //  2
	{0x42, 0x81, 0x91, 0x91, 0x6E}, //  3
	{0x18, 0x28, 0x48, 0xFF, 0x08}, //  4
	{0xF2, 0x91, 0x91, 0x91, 0x8E}, //  5
	{0x1E, 0x29, 0x49, 0x89, 0x86}, //  6
	{0x80, 0x8F, 0x90, 0xA0, 0xC0}, //  7
	{0x6E, 0x91, 0x91, 0x91, 0x6E}, //  8
	{0x70, 0x89, 0x89, 0x8A, 0x7C}  //  9	
};

// Obtener el indice del caracter pasado por parametro dentro de uppercase o lowercase_alphabet
//sirve tanto como para lowercase y uppercase
char index_of_char(char character){
	if(character > 96){
		//lowercase to uppercase
		character-=32;
	}
	return character-65;
}

const char* alphabet_get_char_map(char c){
	if(c > 96){
		//lowercase
		return lowercase_alphabet[index_of_char(c)];
	}else if(c > 64){
		//uppercase
		return uppercase_alphabet[index_of_char(c)];
	}else{
		return numbers[c-48];
	}
} 